<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
	<title>GeoPose Presentation</title>
	<meta name="description" content="GeoPose Website">
	<meta name="keywords" content="GeoPose, Website, OARC, OSCP">
	<meta name="author" content="Mikel Salazar">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<style>html, body { width: 100%; height: 100%; margin:0; }</style>
</head>
<body>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r126/three.min.js"></script>
	<script>

// The elements of the prototype
let scene, camera, light, renderer, canvas, buttons = [];
let hud, hudCamera, hudButtons = [];
let background, globe;
let cursor = null, selected = null;
let lastTime = 0, fps = 0;
let dragging = false, globeInertiaX = 0, globeInertiaY =0;
let width, height;
let logo, menu, sectionTitle, instructions, previousButton, nextButton;
let cameraRotation = { lng: 0, lat: 0}, targetRotation = null, targetAnimation = 100;
let section = 0, previousSection = -1;

/** Defines a button. */
class Button {

	constructor(name, parent, text, size, align = "middle-center", 
		lng = 0, lat = 0, alt = 1, color = 0xffffff, selectionLayer, callback) {
		this.parent = parent;
		this.name = name;
		this.text = text; this.size = size; this.align = align;
		this.lng = lng; this.lat = lat; this.alt = alt;
		this.offsetRotation = 0;

		this.obj = new THREE.Object3D(); this.obj.name = name;
		if (this.parent) this.parent.add(this.obj);

		// Create the selector
		this.selector = new THREE.Mesh(new THREE.BoxGeometry(0.1,0.1,0.1),
			 new THREE.MeshBasicMaterial({opacity:0.0, transparent:true, depthTest:false}));
		this.selector.name = name; this.selector.callback = callback;
		if(selectionLayer) selectionLayer.push(this.selector);
		this.obj.add(this.selector);


		// Create the label
		this.label = new THREE.Mesh(new THREE.TextGeometry( this.text, {
			font:fontRegular, size: size , height:0}),
			new THREE.MeshBasicMaterial({color: color})); 
		this.label.geometry.center();
		this.obj.add(this.label);
		
		// Start updating 
		this.update();
	}

	/** Updates the button elements.*/
	update () {
		if (this.text== "sphere") {
			this.label.geometry = new THREE.SphereGeometry(this.size,32,32);
			this.selector.geometry = new THREE.SphereGeometry(this.size);
 		} else { 
			this.label.geometry = new THREE.TextGeometry(this.text, {
				font:fontRegular, size:this.size , height:0});
			this.label.geometry.center();
			this.label.geometry.computeBoundingBox();
			let boundingBox = this.label.geometry.boundingBox;
			let width = boundingBox.max.x - boundingBox.min.x;
			let height = boundingBox.max.y - boundingBox.min.y;
			let x,y;
			this.label.position.set(0,0,0);
			switch(this.align) {
				case "top-left": x = -width/2; y = height/2; break;
				case "top-center": x = 0; y = height/2; break;
				case "top-right": x = width/2; y = height/2; break;
				case "middle-left":  x = -width/2; y = 0; break; 
				case "middle-center": x = 0; y = 0; break;
				case "middle-right": x = width/2; y = 0; break;
				case "bottom-left": x = -width/2; y = -height/2; break;
				case "bottom-center": x = 0; y = -height/2; break;
				case "bottom-right": x = width/2; y = -height/2; break;
			}

			this.label.position.x += x; this.label.position.y += y;
			this.selector.position.x = this.label.position.x;
			this.selector.position.y = this.label.position.y;
			this.selector.geometry = new THREE.BoxGeometry(width,height,0.1)
		}
		
		let lng = -this.lng * (Math.PI/180), 
			lat = -this.lat * (Math.PI/180),
		 	alt = -this.alt,
			lngSin = Math.sin(lng), lngCos = Math.cos(lng),
			latSin = Math.sin(lat), latCos = Math.cos(lat);

		this.obj.position.z = lngCos * latCos * alt;
		this.obj.position.y = latSin * alt;
		this.obj.position.x = lngSin * latCos * alt;
	
		this.obj.rotation.set(0,0,0);
		this.obj.rotateY(lng);
		this.obj.rotateX(-lat);
		this.obj.rotateY(this.offsetRotation);

	}
} 

// Load the resources
let manager = new THREE.LoadingManager();
manager.onStart = function (url, itemsLoaded, itemsTotal) {
	console.log( 'Started loading file: ' + url + '.\nLoaded ' + itemsLoaded + ' of ' + itemsTotal + ' files.' );
};
manager.onProgress = function (url, itemsLoaded, itemsTotal) {
	console.log( 'Loading file: ' + url + '.\nLoaded ' + itemsLoaded + ' of ' + itemsTotal + ' files.' );
};
manager.onError = function (url) { console.log('There was an error loading ' + url); };
manager.onLoad = function () { console.log('Loading complete!'); init(); };

let fontLoader = new THREE.FontLoader(manager), fontRegular, fontBold;
fontLoader.load("fonts/Aero_Matics_Regular.json", (f) => {fontRegular = f});
fontLoader.load("fonts/Aero_Matics_Bold.json", (f) => {fontBold = f});

let textureLoader = new THREE.TextureLoader(manager),
	starsTexture = textureLoader.load("textures/2k_milky_way.jpg"),
	earthTexture = textureLoader.load("textures/2k_earth_daymap.jpg"),
	normalTexture = textureLoader.load("textures/2k_earth_normals.jpg"),
	cloudTexture = textureLoader.load("textures/2k_earth_clouds.jpg");

function createSection(radius, minLng, maxLng, minLat, maxLat) {
	let c = Math.PI / 180, size = (maxLng - minLng);
	let d = new THREE.SphereGeometry(radius, 64, 32, 
		(-minLng + 270 - size)* c, size * c, minLat * c, (maxLat - minLat)* c)
	return d;
}


/** Initializes the scene. */
function init() {

	renderer = new THREE.WebGLRenderer({antialias:true});
	renderer.autoClear = false;
	document.body.appendChild(renderer.domElement);

	// Create the main scene
	scene = new THREE.Scene(); scene.add(new THREE.PointLight());
	camera = new THREE.PerspectiveCamera(45, 1, 0.1, 1000 );

	// Create the HUD layer
	hud = new THREE.Scene(); hud.add(new THREE.AmbientLight());
	hudCamera = new THREE.PerspectiveCamera(45, 1, 0.1, 1000 );

	// Add the background
	background = new THREE.Mesh(new THREE.SphereGeometry(5, 32, 32), 
		new THREE.MeshBasicMaterial({side: THREE.BackSide,
			map: starsTexture}))
	scene.add(background);

	// Add the HUD elements
	let blue = new THREE.MeshPhongMaterial({color: 0x0040FF, 
		side: THREE.DoubleSide, opacity: 0.5, transparent: true});
	let blue2 = new THREE.MeshPhongMaterial({color: 0x0040FF, 
		side: THREE.DoubleSide, opacity: 0.2, transparent: true});

	let p = Math.PI, d = Math.PI * 2;
	
	hud.add(new THREE.Mesh(createSection(1,0,360,0,74), blue));
	hud.add(new THREE.Mesh(createSection(1,0,360,106,180), blue));
	logo = new Button("Logo", hud, "GeoPose", 0.04, "bottom-right",
		-30, 19, 0.95, 0xffffff, hudButtons, ()=> { console.log("Logo"); });
	menu = new Button("Menu", hud, "Menu", 0.04, "bottom-left",
		30, 19, 0.95, 0xffffff, hudButtons, ()=> { console.log("Menu"); });
	sectionTitle = new Button("Section", hud, "Title", 0.05, "bottom-center",
		0, 20, 0.95, 0xffffff, hudButtons, ()=> { console.log("Sección"); });
	previousButton = new Button("PreviousButton", hud, "< Previous", 
		0.03, "top-right", -30, -19, 0.95, 0xffffff, hudButtons, 
		()=> { 	targetRotation = {lng: (section - 1) * 120, lat:0, t:1};});
	nextButton = new Button("NextButton", hud, "Next >", 
		0.03, "top-left", 30, -19, 0.95, 0xffffff, hudButtons, 
		()=> { targetRotation = { lng:(section + 1) * 120, lat:0, t:1};});
	instructions = new Button("Instructions", hud, "instructions", 0.02, "top-center",
		0, -21, 0.95, 0xffffff, hudButtons, ()=> { console.log("Sección"); });


	// Add the elements of the Presentation
	globe = new THREE.Mesh(new THREE.SphereGeometry(0.5, 32, 32), 
		new THREE.MeshPhongMaterial({color: 0xffffff, map: earthTexture, normalMap: normalTexture}));
	globe.name = "Globe";
	globe.add(new THREE.Mesh(new THREE.SphereGeometry(0.501, 32, 32), 
		new THREE.MeshPhongMaterial({color: 0xffffff, alphaMap: cloudTexture, transparent: true})));
	globe.position.z = -2; globe.rotation.set(0.8,-1.0,0); globeInertiaY = 0.001
	scene.add(globe);
	new Button("Experience1", globe, "sphere", 0.03, "middle-center", 
		90, 42, 0.51, 0x008888, buttons, ()=>{alert("TODO: Show Introduction")}); 
	let et1 = new Button("Experience1Text", globe, "What is Geopose?", 0.03, "middle-center", 
		90, 47, 0.52, 0xffffff, buttons, ()=>{alert("TODO: Show Introduction")}); 
	et1.offsetRotation = Math.PI; et1.update();
	new Button("Experience2", globe, "sphere", 0.03, "middle-center", 
		180, 32, 0.51, 0x008888, buttons, ()=>{alert("TODO: Show Use Cases")}); 
	let et2 = new Button("Experience2Text", globe, "Use Cases", 0.03, "middle-center", 
		180, 37, 0.52, 0xffffff, buttons, ()=>{alert("TODO: Show Use Cases")}); 
	et2.offsetRotation = Math.PI; et2.update();
	new Button("Experience3", globe, "sphere", 0.03, "middle-center", 
		84, 58, 0.51, 0x008888, buttons, ()=>{alert("TODO: Show Testbeds")}); 
	let et3 = new Button("Experience3Text", globe, "Testbeds", 0.03, "middle-center", 
		84, 63, 0.52, 0xffffff, buttons, ()=>{alert("TODO: Show Testbeds")}); 
	et3.offsetRotation = Math.PI; et3.update();
	new Button("Experience4", globe, "sphere", 0.03, "middle-center", 
		205, 35, 0.51, 0x008888, buttons, ()=>{alert("TODO: Show Experience")}); 
	let et4 = new Button("Experience4Text", globe, "Playground", 0.03, "middle-center", 
		205, 40, 0.52, 0xffffff, buttons, ()=>{alert("TODO: Show Playground")}); 
	et4.offsetRotation = Math.PI; et4.update();
	new Button("Experience5", globe, "sphere", 0.03, "middle-center", 
		310, 35, 0.525, 0x008888, buttons, ()=>{alert("TODO: Show Experience")}); 
	let updatesText = 
		"UPDATES                [X]\n" +
		"---------------------\n" +
		"+Version 1.1 Available";
	new Button("Updates", scene, updatesText, 0.015, "middle-right", 
		-30, 0, 0.95, 0x8888ff, hudButtons); 
	let controlsText = 
		"[X]                      CONTROLS\n" +
		"-------------------------\n" +
		"+Rotate the globe with \n"+
		" the mouse.";
	new Button("Controls", scene, controlsText, 0.015, "middle-left", 
		30, 0, 0.95, 0x8888ff, hudButtons); 

	// Add the elements of the Resources
	scene.add(new THREE.Mesh(createSection (1, 91, 109, 90, 105), blue2));
	let developers = new Button("Developers", scene, "DEVELOPERS", 0.03, 
		"middle-center", 100, -2, 0.95, 0xffffff, buttons); 
	new Button("DevelopersIcon", scene, "sphere", 0.05, 
		"middle-center", 100, 8, 0.95, 0x0040FF, buttons); 
	new Button("ImplementersGuide", scene, "Implementers Guide", 0.02, 
		"middle-center", 100, -6, 0.95, 0xffffff, buttons); 
	new Button("GitHubRepository", scene, "GitHub Repository", 0.02, 
		"middle-center", 100, -9, 0.95, 0xffffff, buttons); 
	new Button("TutorialsAndExamples", scene, "Tutorials and Examples", 0.02, 
		"middle-center", 100, -12, 0.95, 0xffffff, buttons); 
	scene.add(new THREE.Mesh(createSection (1, 111, 129, 90, 105), blue2));
	let creators = new Button("Creators", scene, "CREATORS", 0.03, 
		"middle-center", 120, -2, 0.95, 0xffffff, buttons); 
	new Button("CreatorsIcon", scene, "sphere", 0.05, 
		"middle-center", 120, 8, 0.95, 0x0040FF, buttons); 
	new Button("LearningMaterials", scene, "Learning Materials", 0.02, 
		"middle-center", 120, -6, 0.95, 0xffffff, buttons); 
	new Button("ElectronicPressKit", scene, "Electronic Press Kit", 0.02, 
		"middle-center", 120, -9, 0.95, 0xffffff, buttons); 
	new Button("FrequentlyAskedQuestions", scene, "FAQs", 0.02, 
		"middle-center", 120, -12, 0.95, 0xffffff, buttons); 
	scene.add(new THREE.Mesh(createSection (1, 131, 149, 90, 105), blue2));
	let academics = new Button("Academics", scene, "ACADEMICS", 0.03,
		"middle-center", 140, -2, 0.95, 0xffffff, buttons); 
	new Button("AcademicsIcon", scene, "sphere", 0.05, 
		"middle-center", 140, 8, 0.95, 0x0040FF, buttons); 
	new Button("Publications", scene, "Publications", 0.02, 
		"middle-center", 140, -6, 0.95, 0xffffff, buttons); 
	new Button("ScientificData", scene, "Scientific Data", 0.02, 
		"middle-center", 140, -9, 0.95, 0xffffff, buttons); 
	new Button("Illustrations", scene, "Illustrations", 0.02, 
		"middle-center", 140, -12, 0.95, 0xffffff, buttons); 

	

	// Add the elements of the community
	scene.add(new THREE.Mesh(createSection (1, 211, 229, 90, 105), blue2));
	new Button("Implementers", scene, "IMPLEMENTERS", 0.03, "middle-center", 
		220, -2, 0.95, 0xffffff, buttons); 
	new Button("ImplementersIcon", scene, "sphere", 0.05, 
		"middle-center", 220, 8, 0.95, 0x0040FF, buttons); 
	new Button("ContributeToOurDatabase", scene, "Contribute to our codebase\n with a implementation of\n        the logical model", 0.018, 
		"middle-center", 220, -8, 0.95, 0xffffff, buttons); 
	scene.add(new THREE.Mesh(createSection (1, 231, 249, 90, 105), blue2));
	new Button("Members", scene, "MEMBERS", 0.03, "middle-center",
		240, -2, 0.95, 0xffffff, buttons); 
	new Button("MembersIcon", scene, "sphere", 0.05, 
		"middle-center", 240, 8, 0.95, 0x0040FF, buttons); 
	new Button("ContributeToOurDatabase", scene, " Make sure that the logical\nmodel covers all user cases", 0.018, 
		"middle-center", 240, -8, 0.95, 0xffffff, buttons); 
	scene.add(new THREE.Mesh(createSection (1, 251, 269, 90, 105), blue2));
	new Button("Testers", scene, "TESTERS", 0.03, "middle-center",
		260, -2, 0.95, 0xffffff, buttons); 
	new Button("TestersIcon", scene, "sphere", 0.05, 
		"middle-center", 260, 8, 0.95, 0x0040FF, buttons); 
	new Button("ContributeToOurDatabase", scene, "Validate implementations\n  by testing them out in\n  different environments", 0.018, 
		"middle-center", 260, -8, 0.95, 0xffffff, buttons); 
	
	// Create the events
	window.addEventListener('resize', resize, false);
	window.addEventListener('contextmenu', (e) => { e.preventDefault(); });
	window.addEventListener('keydown', (e) => {
		switch (e.key) {
			case "1": targetRotation = {lng: 0, lat: 0, t:1}; break;
			case "2": targetRotation = {lng: 120, lat: 0, t:1}; break;
			case "3": targetRotation = {lng: 240, lat: 0, t:1}; break;
		}
		console.log(e);
	});
	window.addEventListener('pointerdown', (e) => {
		select(e.x, e.y, hudCamera, hudButtons);
		if (!selected) select(e.x, e.y, camera, buttons);
		if (!selected) select(e.x, e.y, camera, [globe]);
		console.log("Selected: " + ((selected != null)? selected.name : "none"));
	});
	window.addEventListener('pointermove', (e) => { 
		if (e.buttons == 1 && selected == globe) {
			globe.rotation.x += (e.y - cursor.y) / 1000;
			globe.rotation.y += (e.x - cursor.x) / 1000;
			dragging = true; globeInertiaX = globeInertiaY = 0;
		} else {
			if (dragging) {
				globeInertiaX += (e.y - cursor.y) / 1000;
				globeInertiaY += (e.x - cursor.x) / 1000;
				dragging = false;
			}
		}

		if (e.buttons == 2) {
			cameraRotation.lng -= (e.x - cursor.x) / 10;
			cameraRotation.lat += (e.y - cursor.y) / 10;
		}
		cursor = {x: e.x, y: e.y};
	});
	window.addEventListener('pointerup', (e) => { 
		if(selected && selected.callback) selected.callback();
	 });

	// Resize the viewport and render it
	resize(); draw();
}

/** Selects an object if iyt is at a particular position on screen.*/
function select (x,y, camera, objects) {
	let raycaster = new THREE.Raycaster();
	raycaster.setFromCamera(new THREE.Vector2(
		(x / width) * 2 - 1, -(y / height) * 2 + 1), camera);
	let intersects = raycaster.intersectObjects(objects);
	selected = (intersects.length>0)? intersects[0].object : null;
	return selected;
}

/** Resize the viewport. */
function draw(time) {

	// Calculate the time
	let deltaTime = time - lastTime; lastTime = time;

	// Rotate the background
	background.rotation.y = time* 0.00001;

	// Rotate the globe
	if (globeInertiaX > 0.1) globeInertiaX = 0.1;
	if (globeInertiaY > 0.1) globeInertiaY = 0.1;
	globe.rotation.x += globeInertiaX; globe.rotation.y += globeInertiaY;
	if (globe.rotation.x > +Math.PI/2) globe.rotation.x = +Math.PI/2;
	if (globe.rotation.x < -Math.PI/2) globe.rotation.x = -Math.PI/2;

	// Rotate the camera
	if (cameraRotation.lng < 0) cameraRotation.lng += 360;
	else cameraRotation.lng %= 360;
	if (targetRotation) {
		if(targetRotation.sLng == undefined) targetRotation.sLng = cameraRotation.lng;
		if(targetRotation.sLat == undefined) targetRotation.sLat = cameraRotation.lat;

		targetRotation.t -= deltaTime/400;
		if (targetRotation.t > 0) {
			cameraRotation.lng = targetRotation.lng
				 - ((targetRotation.lng - targetRotation.sLng) * targetRotation.t);
			cameraRotation.lat = targetRotation.lat
				- ((targetRotation.lat - targetRotation.sLat) * targetRotation.t);
		} else {
			cameraRotation.lng = targetRotation.lng;
			cameraRotation.lat = targetRotation.lat;
			targetRotation = null;
		}
		
	}
	if (cameraRotation.lat > +90) cameraRotation.lat = +90;
	if (cameraRotation.lat < -90) cameraRotation.lat = -90;
	camera.rotation.set(0,0,0); 
	camera.rotateY(-cameraRotation.lng * Math.PI/180); 
	camera.rotateX(cameraRotation.lat * Math.PI/180);

	// Change the section, based on the position of the camera
	section = Math.round(cameraRotation.lng / 120) % 3;
	if (section != previousSection) {
		console.log("Change: " + section);
		switch(section) {
			case 0:
				sectionTitle.text = "Presentation";
				nextButton.text = "Resources >";
				previousButton.text = "< Community";
				instructions.text = "Travel around the globe and\n  discover different demos";
			break;
			case 1:
				sectionTitle.text = "Resources"; 
				nextButton.text = "Community >";
				previousButton.text = "< Presentation";
				instructions.text = "Choose your own adventure";
			break;
			case 2:
				sectionTitle.text = "Community"; 
				nextButton.text = "Presentation >";
				previousButton.text = "< Resources";
				instructions.text = "   Become an active participant of\nthe GeoPose Standardization Group"
			break;
		}
		sectionTitle.update();
		nextButton.update();
		previousButton.update();
		instructions.update();
		previousSection = section;
	}

	// Render the two layers
	renderer.render(scene, camera);
	renderer.clearDepth();
	renderer.render(hud, hudCamera);

	// Call this function as soon as possible
	requestAnimationFrame(draw);
}


/** Resize the viewport. */
function resize() {
	width = window.innerWidth; height = window.innerHeight;
	let aspect = camera.aspect = hudCamera.aspect = width/height;
	camera.updateProjectionMatrix(); hudCamera.updateProjectionMatrix();
	renderer.setSize(width, height);
}


	</script>
</body>
</html>